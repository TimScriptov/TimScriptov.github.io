<!DOCTYPE html>
<html lang="ru">

  <head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=yes, minimum-scale=1.0">
	<meta name="description" content="">
	<meta name="author" content="Иван Тимашков">
	<title>Урок 34. Getters и Setters</title>

	<link href="../css/bootstrap.css" rel="stylesheet">
	<link href="../css/article_style.css" rel="stylesheet">
	<link href="../css/hightlight-styles/androidstudio.css" rel="stylesheet">
  </head>

  <body>

	<div class="page__inner">
	  <div class="main main_width-limit">
		<div class="content">

		  <html>
<body><p>Доступ к свойствам напрямую не является хорошей практикой.
Иногда вам нужно проверить значение в случае недопустимого ввода или выполнить некоторые другие проверки или вычисления данных перед назначением или доступом к значению свойства.
Предположим, что у нас есть класс <b>User</b> со свойством <b>age</b>:</p>
<pre><code class="kotlin">class User {
  var age: Int = 0;
  fun printInfo() {
    println("The user is $age years old.");
  }
}</code></pre>
<p>Свойство объекта можно легко присвоить недопустимому значению. Вот пример:</p>
<pre><code class="kotlin">class User {
  var age: Int = 0;
  fun printInfo() {
    println("The user is $age years old.");
  }
}
fun main(args: Array&lt;String&gt;) {
  // client code
  val obj = User();
  obj.age = -12;
  obj.printInfo();
}</code></pre>
<p><b>Getters</b> и <b>setters</b> помогают реализовать  <b>гибкость</b> в доступе к свойствам. Сеттер определяется с помощью ключевого слова <b>set</b> и позволяет определить поведение, когда значение присваивается свойству:</p>
<pre><code class="kotlin">class User {
  var age: Int = 0
  set(value) {
    if (value > 0) {
      field = value;
    }
  }
  fun printInfo() {
    println("The user is $age years old.");
  }
}
fun main(args: Array&lt;String&gt;) {
  // client code
  val obj = User();
  obj.age = -12;
  obj.printInfo();
  obj.age = 11;
  obj.printInfo();
}</code></pre>
<p>Ключевое слово <b>field</b> относится к свойству (<b>age в этом случае</b>).
Каждый раз, когда клиентский код назначает новое значение для свойства age, в качестве аргумента вызывается <b>setter</b> со значением <b>value</b>. Код проверяет, больше ли значение, чем 0, и только затем присваивает его свойству.
Следующий код будет выводить 0, так как значение <b>-12</b> не будет присвоено возрасту:</p>
<pre><code class="kotlin">class User {
  var age: Int = 0
  set(value) {
    if (value > 0) {
      field = value;
    }
  }
  fun printInfo() {
	println("The user is $age years old.");
  }
}
fun main(args: Array&lt;String&gt;) {
  // client code
  val obj = User();
  obj.age = -12;
  obj.printInfo();
  obj.age = 11;
  obj.printInfo();
}</code></pre>
<p>Getter, напротив, вызывается каждый раз, когда считывается значение свойства.
Мы можем, например, добавить 2 к значению свойства <b>age</b> при его доступе:</p>
<pre><code class="kotlin">class User {
  var age: Int = 0
  get() {
    return field + 2;
  }
  set(value) {
    if (value > 0) {
      field = value;
    }
  }
  fun printInfo() {
	println("The user is $age years old.");
  }
}
fun main(args: Array&lt;String&gt;) {
  // client code
  val obj = User();
  obj.age = -12;
  obj.printInfo();
  obj.age = 11;
  obj.printInfo();
  println("Accessing age gives the value ${obj.age}");
}</code></pre>
<p>Ключевое слово <b>field</b> относится к свойству (<b> age в этом случае</b>).
Свойство может иметь как getter, так и setter.</p>
			</body>
		  </html>

		</div>
	  </div>               
	</div>    


	<script src="../js/highlight.pack.js"></script>
	<script>hljs.initHighlightingOnLoad();</script>
  </body>
</html>
 
