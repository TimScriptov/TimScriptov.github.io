<!DOCTYPE html>
<html lang="ru">
  
	<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no">
    <meta name="author" content=""/>
    
	<title>Урок 172. OpenGL. Perspective. Frustum. Ortho.</title>
 <link href="../css/bootstrap.css" rel="stylesheet">
    <link href="../css/article_style.css" rel="stylesheet">
    <link href="../css/hightlight-styles/androidstudio.css" rel="stylesheet">
	</head>
	
	<body>
      <div class="page__inner">
      <div class="main main_width-limit">
      <div class="content">
      
		<p>В этом уроке:</p>
<p>- используем perspective-режим<br/>- описываем frustum<br/>- используем ortho-режим</p>
<p>Переходим в 3D. И для начала разберемся, как нам реализовать перспективу. Т.е. чтобы по мере удаления от нас предметы становились меньше, а по мере приближения – больше.</p>
<p>Скачивайте <a href="https://github.com/startandroid/lessons_opengl" target="_blank" rel="noopener noreferrer">исходники</a> и открывайте модуль <b>lesson172_perspective</b>.</p>
<p>Смотрим код, класс <b>OpenGLRenderer</b>. В методе <b>prepareData</b> заданы две вершины.</p>
<pre><code class="java">float x1 = -0.5f, y1 = -0.8f, x2 = 0.5f, y2 = -0.8f;
 
float[] vertices = {
        x1, y1, 0.0f, 1.0f,
        x2, y2, 0.0f, 1.0f,
};
</code></pre>
<p>Обратите внимание, что для каждой вершины используем 4 значения – x,y,z и w. Если с x,y,z все понятно, это просто координаты трех осей, то 4-е значение (w) нам пока неизвестно, раньше мы его не использовали. Если его явно не задавать в данных о вершине, то по умолчанию в шейдер придет значение 1. Мы пока тоже сделаем его равным одному.</p>
<p>В методе onDrawFrame указано, что из этих вершин нам надо нарисовать две точки</p>
<pre><code class="java">glDrawArrays(GL_POINTS, 0, 2);
</code></pre>
<p>Запустим приложение</p>
<p><img style="border: 1px solid black;" src="data:image/webp;base64,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" alt="" data-pagespeed-url-hash="2579026831" onload="pagespeed.CriticalImages.checkImageForCriticality(this);"/></p>
<p>На экране две зеленые точки</p>
<p>Теперь выясним зачем нужно это 4-е значение вершины - w. Оно используется системой для создания перспективы. Когда системе приходит на вход вершина (x,y,z,w), система делит координаты x,y,z на w и в итоге получает вершину с координатами (x/w, y/w, z/w), и это деление дает эффект перспективы. Давайте убедимся в этом. Перепишем массив в <b>prepareData</b>:</p>
<pre><code class="java">float[] vertices = {
        x1, y1, 0.0f, 1.0f,
        x1, y1, 0.0f, 1.5f,
        x1, y1, 0.0f, 2.0f,
        x1, y1, 0.0f, 2.5f,
        x1, y1, 0.0f, 3.0f,
        x1, y1, 0.0f, 3.5f,
 
        x2, y2, 0.0f, 1.0f,
        x2, y2, 0.0f, 1.5f,
        x2, y2, 0.0f, 2.0f,
        x2, y2, 0.0f, 2.5f,
        x2, y2, 0.0f, 3.0f,
        x2, y2, 0.0f, 3.5f,
};
</code></pre>
<p>Мы продолжаем использовать всего две точки (x1, y1, 0) и (x2, y2, 0), но теперь каждую из них мы выводим 6 раз, меняя значение w от 1 до 3.5.</p>
<p>Логично предположить, что если 6 раз нарисовать одну и ту же точку, то на экране в итоге будет одна точка. Но мы используем различные w для каждой из 6-ти точек. Т.е. при рисовании каждой точки, ее координаты будут поделены на w, а значит будут отличаться от остальных. Например, для точки (x1,y1,0) мы получим набор точек:(x1 / 1, y1 / 1, 0 / 1)<br/>(x1 / 1.5, y1 / 1.5, 0 / 1.5)<br/>(x1 / 2, y1 / 2, 0 / 2) <br/>и т.д.</p>
<p>Т.е. это будут уже абсолютно разные точки и, соответственно, нарисованы они будут в разных местах, а не в одном.</p>
<p>В методе <b>onDraw</b> не забываем указать методу glDrawArrays, что нам теперь надо нарисовать не 2, а 12 вершин.</p>
<pre><code class="java">glDrawArrays(GL_POINTS, 0, 12);
</code></pre>
<p>Запускаем</p>
<p><img src="data:image/webp;base64,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" alt="" data-pagespeed-url-hash="2503810818" onload="pagespeed.CriticalImages.checkImageForCriticality(this);"/></p>
<p>Каждая из двух точек теперь превратилась в 6 точек. И обратите внимание как они расположены друг относительно друга. Создается иллюзия перспективы, т.е. точки как будто удаляются от нас. На размер точки пока не обращайте внимания, он не меняется. Смотрите именно на расположение. Чем больше значение w, тем «дальше» от нас находится точка в итоговом изображении.</p>
<p>Когда я сам изучал эту тему, у меня случился некий «разрыв шаблона». Я как-то рассчитывал, что я просто буду задавать z-координату и, тем самым, буду указывать системе насколько удалена или приближена будет ко мне точка. А тут какая то w.</p>
<p>Давайте попробуем забыть про w и использовать z.</p>
<p>Перепишем массив в <b>prepareData</b>:</p>
<pre><code class="java">float[] vertices = {
        x1, y1, -1.0f,
        x1, y1, -1.5f,
        x1, y1, -2.0f,
        x1, y1, -2.5f,
        x1, y1, -3.0f,
        x1, y1, -3.5f,
 
        x2, y2, -1.0f,
        x2, y2, -1.5f,
        x2, y2, -2.0f,
        x2, y2, -2.5f,
        x2, y2, -3.0f,
        x2, y2, -3.5f,
};
</code></pre>
<p> </p>
<p>И замените значение константы  POSITION_COUNT с 4 на 3.</p>
<pre><code class="java">private final static int POSITION_COUNT = 3;
</code></pre>
<p>Эта константа используется в методе glVertexAttribPointer и обозначает кол-во компонентов, которые мы используем чтобы передать данные о расположении вершины. В предыдущем примере мы использовали 4 компонента (XYZW), а теперь будем только 3 (XYZ).</p>
<p>Мы убрали из вершины данные о w (при передаче данных в шейдер оно автоматически будет равно 1). Теперь мы используем разные z-координаты. Т.е. интуитивно кажется, что должен получится примерно такой же результат, т.е. точки должны выстроится по линии перспективы, все дальше и дальше, т.к. они отдаляются от нас за счет z-координаты.</p>
<p>Запускаем</p>
<p><img src="data:image/webp;base64,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" alt="" data-pagespeed-url-hash="2428594805" onload="pagespeed.CriticalImages.checkImageForCriticality(this);"/></p>
<p>Видим всего две точки. Фокус не удался. И вот тут надо будет понять одну очень важную вещь. Наш экран – это двумерное изображение. Т.е. у него всего две оси – X и Y. Соответственно, только эти координаты он учитывает при расположении на экране всех объектов. И если мы хотим создать иллюзию удаления объекта, т.е. уменьшения его в размерах и некоторого смещения по линии перспективы, то нам необходимо менять именно X и Y значения.</p>
<p>Тут можно привести аналогию с листом бумаги. Вы взяли лист и нарисовали на нем, например, домик. А затем вас попросили нарисовать точно такой же домик, но чтобы он стоял чуть подальше «вглубь» листа. Вы просто возьмете и нарисуете тот же самый домик, но немного меньшего размера, потому что он расположен чуть «дальше» от вас и ваш мозг знает, что удаленность объекта можно эмулировать, просто сделав его меньшего размера. Но при этом вы же не использовали никаких z-координат. Вы нарисовали все на двумерном листе и использовали для этого только оси X и Y.</p>
<p>С OpenGL ситуация аналогична. Система ожидает от вас x и y координаты, чтобы нарисовать их на двумерном экране. И любую перспективу объекта она сможет изобразить, только используя x и y координаты. Мы видели на примерах точек, как значение w может нам помочь. Оно меняет x и y, и дает нам перспективу в итоговом изображении.</p>
<p>Но тогда возникает резонный вопрос - а зачем вообще нужна координата z? Есть и для нее работа. В нашем двумерном изображении она используется буфером глубины (который еще называется z-буфером). В качестве примера можно рассмотреть случай, когда у вас уже на этапе рисования системой изображения есть две совпадающие по (x,y) точки. Например: (1,2,0) и (1,2,-1). Т.е. они обе имеют координаты x=1 и y=2, а отличаются только по z. И допустим одна из этих точек красная, а другая синяя. Какую из них система должна нарисовать на экране?</p>
<p>По умолчанию будет видна та, которая была нарисована последней. Т.е. она просто будет нарисована поверх предыдущей. Но это вовсе не всегда правильно с точки зрения 3D-сцены. Мы ведь можем сначала отправить на отрисовку ближний к себе объект, а затем дальний. И в правильной 3D-сцене, если оба этих объекта находятся на одной линии нашего взгляда, ближний объект должен перекрывать собой дальний. Но по умолчанию будет виден дальний, потому что он был нарисован после ближнего и просто затер его. И вот тут выручает z-координата. Именно по ней буфер глубины определит, которая из точек находится «ближе» к вам, а которая дальше, и отобразит ближнюю. А дальняя, соответственно не будет нарисована.</p>
<p>Также тут стоит отметить, что z-координата ограничена длиной 1 в каждую сторону. Т.е. все точки, которые будут иметь z-координату больше 1 или меньше -1, просто не будут нарисованы.  Т.е. аналогично, как и координаты x и y. Если помните, мы говорили об этом в уроке 169.</p>
<p><img style="border: 1px solid black;" src="data:image/webp;base64,UklGRh4CAABXRUJQVlA4TBECAAAvPUFAAKegoJEUZ/UQFCAB/fWLF2wohCTJ6dM624d5gxxcXlEkqdHg5ZDEF7coyJ14yfwHuP/jgYt/gOcN5QQNWy9c3/EMHkBjgnKShpLqljgABLeNHElVk3Pq+f9rd3q6XYP1XqyI/jthI8mRqtHn+bp8sKH+35xJ5lJzM7RLxU68ofIgu0YydrJpyhhBNiWWIDtAOWahDq2IbJoyxtjNpb77ZIvPVQ7aXo6lPmXT+zFe/kSjbz754m2UJ2wR/ZkyBreHF6V2yvvz+krm6Ieshb73ZIoHKH8Ac8kNG+WR3ckkItIkjx45nWKUyP40X/nHxwf3AM5lF831LXbKQ2Soy1eLzOXrqJEx6H3RWhgpv9+dxGYNssfHYHiWbqY8caqxi24lJN6ZL95MeeIWEZYqeTahkpj4bOVPuDNGCeSdsQeEE7B8JyNKIE4i7j8w3H9guP/AcP+B4f4Dw/0HhvsPDPcfGO4/MNx/YLj/wHD/geH+80hcfyjkty3fP0msXABS4Qjz8krQ5Y0QrXAkyI4xji5vJLnCEVrdjUCMg8sb4VnhyCRzCTIOLm+EZ4UjQTaYcYMSM1SVXhkX/Sk71Lg1c8mbuQTXD5I0zMSIS/sgIOMfH5/dA3R5I1TfAjIOL2/kfhhaX7QWIOPw8kYShqF2lg4xblPeCMEKR4ZWGpBxy/JGVLndndhAxj+/O2M2cf6jAA==" alt="" data-pagespeed-url-hash="2353378792" onload="pagespeed.CriticalImages.checkImageForCriticality(this);"/></p>
<p>Т.е. все итоговые точки должны лежать в пределах от -1 до +1 по каждой из трех осей.</p>
<p>Когда я дочитал до этого момента, я немного приуныл, потому что все это выглядит как-то жутко неудобно, странно и непонятно. Особенно w-значение, которое надо каким-то образом самому рассчитывать, чтобы задать то или иное расстояние удаления объекта.</p>
<p>Но! Все оказалось совсем не так печально, как могло показаться. OpenGL любезно предоставляет механизмы, которые позволят нам ничего не знать про w-значение, а для указания расстояния до объекта использовать таки z-координату. Для этого нам просто необходимо будет создать матрицу и использовать ее.</p>
<p>Основной смысл в том, что существует две системы координат: <br/>1) Первая - это 2D, которую мы только что рассмотрели. Где пара x и y задает расположение точки на экране, z используется буфером глубины, а w используется для корректировки xyz чтобы получилась перспектива. Именно в этой системе мы с вами работали до сих пор.<br/>2) Вторая система координат - это виртуальное 3D пространство. Оно имеет три оси координат, и в нем координаты xyz используются для указания расположения объекта. Именно в этой системе мы будем создавать наше изображение. А система с помощью матрицы, будет конвертировать это все в первую систему, т.е. в обычные координаты 2D экрана.</p>
<p>Т.е. мы будем задавать вершину в 3D, используя три координаты (x,y,z) и передавать ее в шейдер. Также в шейдер мы будем передавать матрицу. А шейдер с помощью матрицы будет преобразовывать вершину и получать на выходе (x,y,z,w) значения, в которых уже будет рассчитана перспектива и именно эти значения будут использованы системой для рисования.  Т.е. матрица за нас сама рассчитает, как из указанного нами z, получить w, чтобы объект был нарисован так, как будто он находится на указанном нами расстоянии (z). Тем самым матрица выполнит переход от виртуального трехмерного мира к двумерному экрану.</p>
<p>Итак, нам нужно создать эту волшебную матрицу, передать ее в шейдер и написать в шейдере использование этой матрицы. Перед тем, как создать матрицу, нам надо понять, что именно она будет делать. Смотрим на картинку.</p>
<p><img src="images/lesson172/lesson1.png" alt="" width="640" height="385"/></p>
<p><b>Camera position</b> – это точка, в которой находится камера. Т.е. с этой точки мы будем видеть изображение.</p>
<p><b>Near plane</b> и <b>Far plane</b> – ближняя и дальняя границы видимости. Направление «взгляда» камеры проходит через центр этих границ. Также от камеры идут четыре луча, которые проходят через вершины этих границ и в итоге образуют пирамиду. Камера будет видеть все, что находится в этой пирамиде между <b>near</b> и <b>far</b> границами (эта область называется <b>frustum</b>).</p>
<p>Т.е. как в итоге будет получено изображение на экране?</p>
<p>1) Сначала мы рисуем свои объекты, которые хотим видеть. Для этого, мы как обычно задаем массив вершин и просим нарисовать нужные нам объекты. Т.е. все как мы делали ранее, в прошлых уроках. Единственное отличие – мы теперь будем использовать z-координату. Это даст нам возможность построить полноценное 3D изображение, т.е. "приближать" и "отдалять" объекты.</p>
<p>2) Мы формируем frustum-матрицу, т.е. матрицу, которая будет содержать в себе данные о пирамиде (которую мы только что обсудили). Для этого мы укажем расстояния от камеры до near и far границ, и размеры near-границы. Этого будет достаточно, чтобы полностью описать frustum-зону.</p>
<p>3) В шейдере мы применяем матрицу из п.2 к нашим вершинам из п.1. Тем самым будет выполнена проекция трехмерных объектов на двумерную поверхность. Т.е. будет выполнена та часть работы, про которую я рассказывал в начале урока, когда объем переходит в плоскость, и для создания перспективы используется w-значение, а z используется как z-буфер.</p>
<p>Т.е. идет преобразование виртуальных 3D координат в реальные 2D-координаты, чтобы вывести изображение на двумерный экран и сохранить видимость 3D.</p>
<p>И, как вы помните, мы говорили о том, что на двумерном экране у нас есть лимиты по каждой из осей. Т.е. точки, которые выходят за координаты -1 и 1 по любой из трех осей, не будут нарисованы. Frustum-матрица во время преобразования из 3D-сцены в 2D-экран рассчитывает все так, что объекты, которые находятся вне frustum-зоны, после преобразования в 2D будут находиться за координатами -1 и 1, и, соответственно, не будут нарисованы.</p>
<p>Давайте уже от теории перейдем к практике и создадим frustum-матрицу</p>
<p>Перепишем вершинный шейдер <b>vertex_shader.glsl</b>:</p>
<pre><code class="java">attribute vec4 a_Position;
uniform mat4 u_Matrix;
 
void main()
{
    gl_Position = u_Matrix * a_Position;
    gl_PointSize = 5.0;
}
</code></pre>
<p>Раньше мы просто передавали координаты вершины (a_Position) в систему (gl_Position). Теперь же мы преобразуем их с помощью матрицы, которая выполнит преобразования 3D-сцены в 2D-экран. Для этого мы добавляем в шейдер матрицу u_Matrix, как uniform-параметр. И будем умножать эту матрицу на a_Position.</p>
<p>В методе <b>bindData</b> мы добавляем код для получения доступа к матрице в шейдере</p>
<pre><code class="java">private void bindData(){
    // координаты
    …
 
    // цвет
    …
 
    // матрица
    uMatrixLocation = glGetUniformLocation(programId, "u_Matrix");
}
</code></pre>
<p>Ничего нового для нас. Используем метод glGetUniformLocation и указываем программу и имя переменной в шейдере. А переменная uMatrixLocation уже была объявлена мною в исходниках.</p>
<p>Осталось создать матрицу и передать ее в шейдер.</p>
<p>Создаем в этом же классе метод <b>bindMatrix</b>:</p>
<pre><code class="java">private void bindMatrix(int width, int height) {
    float left = -1.0f;
    float right = 1.0f;
    float bottom = -1.0f;
    float top = 1.0f;
    float near = 1.0f;
    float far = 8.0f;
 
    Matrix.frustumM(mProjectionMatrix, 0, left, right, bottom, top, near, far);
    glUniformMatrix4fv(uMatrixLocation, 1, false, mProjectionMatrix, 0);
}
</code></pre>
<p>Здесь мы указываем все параметры frustum области. <b>near</b> и <b>far</b> – это расстояния от камеры до near и far границ. Переменные <b>left</b>, <b>right</b>, <b>bottom</b> и <b>top</b> – это координаты сторон near-границы. Если left=-1 и right=1, то нетрудно посчитать, что ширина near в нашей трехмерной сцене будет равна 2. Аналогично и высота будет равна 2, т.к. bottom=-1, а top=1.</p>
<p>Тут важно понимать, что абсолютно не важно какая ширина/высота будет у near границы. В итоге все равно все это будет сконвертировано матрицей к диапазону от -1 до +1 по осям X и Y. Просто, если вы сделаете ширину near равной 100, то и координаты вершин ваших объектов будут примерно того же порядка. А если сделаете ширину 2 (т.е. от -1 до 1, как в нашем примере), то и координаты вершин будут в районе от -1 до 1. Тут как вам удобнее.</p>
<p>Все эти параметры мы передаем в метод Matrix.<b>frustumM</b>. Кроме них мы передаем туда матрицу <b>mProjectionMatrix</b>, в которую будет записан результат. Второй параметр метода – это с какого элемента матрицы записывать в нее данные. Указываем 0.</p>
<p>Методом <b>glUniformMatrix4fv</b> передаем матрицу в шейдер. Для этого указываем позицию матрицы – uMatrixLocation, и данные матрицы – mProjectionMatrix. Для остальных параметров используем значения по умолчанию, они нам пока не интересны.</p>
<p>На вход методу bindMatrix приходят width и height. Пока мы их не используем, но чуть дальше будем.</p>
<p>Метод bindMatrix будем вызывать в onSurfaceChanged и передавать туда размеры surface.</p>
<pre><code class="java">@Override
public void onSurfaceChanged(GL10 arg0, int width, int height) {
    glViewport(0, 0, width, height);
    bindMatrix(width, height);
}
</code></pre>
<p>Запускаем приложение</p>
<p><img src="data:image/webp;base64,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" alt="" data-pagespeed-url-hash="2202946766" onload="pagespeed.CriticalImages.checkImageForCriticality(this);"/></p>
<p>Теперь, когда мы использовали матрицу, начали действовать z-координаты, которые мы указывали для вершин. И мы получили точки в перспективе.</p>
<p>Давайте рассмотрим более интересный пример. Вместо точек будем рисовать треугольники.</p>
<p>Перепишем <b>prepareData</b>:</p>
<pre><code class="java">private void prepareData() {
    float z1 = -1.0f, z2 = -1.0f;
 
    float[] vertices = {
            // первый треугольник
            -0.7f, -0.5f, z1,
            0.3f, -0.5f, z1,
            -0.2f, 0.3f, z1,
 
            // второй треугольник
            -0.3f, -0.4f, z2,
            0.7f, -0.4f, z2,
            0.2f, 0.4f, z2,
    };
 
    vertexData = ByteBuffer
            .allocateDirect(vertices.length * 4)
            .order(ByteOrder.nativeOrder())
            .asFloatBuffer();
    vertexData.put(vertices);
}
</code></pre>
<p>Будем рисовать два одинаковых по размеру треугольника. z-координаты вершин вынесем в переменные z1 и z2 для удобства. Меняя значение этих переменных, мы будем менять расстояние до треугольников в 3D сцене.  z1 - расстояние до первого треугольника, а z2 - до второго.</p>
<p>Перепишем метод <b>onDrawFrame</b>:</p>
<pre><code class="java">@Override
public void onDrawFrame(GL10 arg0) {
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
 
    // зеленый треугольник
    glUniform4f(uColorLocation, 0.0f, 1.0f, 0.0f, 1.0f);
    glDrawArrays(GL_TRIANGLES, 0, 3);
 
 
    // синий треугольник
    glUniform4f(uColorLocation, 0.0f, 0.0f, 1.0f, 1.0f);
    glDrawArrays(GL_TRIANGLES, 3, 3);
}
</code></pre>
<p>В метод <b>glClear</b> мы добавили переменную GL_DEPTH_BUFFER_BIT. Это нужно для очистки буфера глубины.</p>
<p>Далее для каждого треугольника мы задаем цвет и просим систему нарисовать его.</p>
<p>Также в начало метода onSurfaceCreated надо добавить строчку.</p>
<pre><code class="java">glEnable(GL_DEPTH_TEST);
</code></pre>
<p>Эта строка включает использование буфера глубины. Это позволит системе определять какая точка находится ближе к нам и отображать именно ее. Об этом мы уже подробно говорили чуть раньше.</p>
<p>Запускаем</p>
<p><img src="data:image/webp;base64,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" alt="" data-pagespeed-url-hash="2127730753" onload="pagespeed.CriticalImages.checkImageForCriticality(this);"/></p>
<p>Видим два одинаковых треугольника.</p>
<p>Теперь меняя параметры z1 и z2 можем менять расстояние до треугольников.</p>
<p>Нарисуем второй треугольник подальше</p>
<p>Для этого поменяем значения z-координат в методе <b>prepareData</b></p>
<pre><code class="java">float z1 = -1.0f, z2 = -3.0f;
</code></pre>
<p>Результат</p>
<p><img src="data:image/webp;base64,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" alt="" data-pagespeed-url-hash="2052514740" onload="pagespeed.CriticalImages.checkImageForCriticality(this);"/></p>
<p>Теперь вернем второй на место, а первый отдалим</p>
<pre><code class="java">float z1 = -2.0f, z2 = -1.0f;
</code></pre>
<p><img src="data:image/webp;base64,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" alt="" data-pagespeed-url-hash="1977298727" onload="pagespeed.CriticalImages.checkImageForCriticality(this);"/></p>
<p>Отдалим оба</p>
<pre><code class="java">float z1 = -3.0f, z2 = -3.0f;
</code></pre>
<p><img src="data:image/webp;base64,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" alt="" data-pagespeed-url-hash="1390879733" onload="pagespeed.CriticalImages.checkImageForCriticality(this);"/></p>
<p>z-координата работает, как положено.</p>
<p>Когда мы определяли расстояние до near и far границ, мы делали это от точки (0,0,0). Именно там находится по умолчанию камера. Кроме этого, камера направлена вдоль оси Z, в сторону уменьшения (т.е. по мере удаления от камеры значение z будет уменьшаться). Как изменить положение и направление камеры, мы узнаем в одном из следующих уроков, а пока примем это как данность.</p>
<p>Исходя из этой информации и вспомнив, что near мы установили = 1, а far = 8, можно посчитать, что камера будет видеть все объекты, имеющие z-координату от -1 до -8.</p>
<p>Попробуем задать такие значения</p>
<pre><code class="java">float z1 = -0.5f, z2 = -9.0f;
</code></pre>
<p>Запускаем</p>
<p><img src="data:image/webp;base64,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" alt="" data-pagespeed-url-hash="1315663720" onload="pagespeed.CriticalImages.checkImageForCriticality(this);"/></p>
<p>Оба треугольника теперь находятся за пределами frustum и камера их не видит.</p>
<p>В нашей матрице есть один небольшой недочет, который нам надо исправить. Давайте посмотрим в чем состоит баг.</p>
<p>Зададим параметры z1 и z2</p>
<pre><code class="java">float z1 = -1.0f, z2 = -1.0f;
</code></pre>
<p>Запустим приложение</p>
<p><img src="data:image/webp;base64,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" alt="" data-pagespeed-url-hash="1240447707" onload="pagespeed.CriticalImages.checkImageForCriticality(this);"/></p>
<p>Повернем экран</p>
<p><img src="data:image/webp;base64,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" alt="" data-pagespeed-url-hash="1165231694" onload="pagespeed.CriticalImages.checkImageForCriticality(this);"/></p>
<p>Видно, что картинка не одинакова. Разбираемся почему. 3D-объекты из frustum сначала проецируются в 2D-изображение на near-границу, а потом это изображение с near растягивается на реальный экран девайса. Near-граница у нас квадратная. А вот экран девайса вовсе не квадратный, а прямоугольный. Причем в портретной ориентации высота больше ширины, а в альбомной – ширина больше высоты. Т.е. квадратное изображение у нас растягивается на прямоугольный экран и мы видим искаженную картинку. Исправляется это легко. Нам нужно просто сделать соотношение сторон near-границы таким же, как и соотношение сторон экрана.</p>
<p>Т.е. если экран у нас в портретном режиме, например, 480*800, то мы делим оба этих значения на меньшее из них, т.е. на 480 и получим 1*1.66. Мы получили соотношение сторон экрана. И именно эти значения будем использовать для определения размеров near-границы. Т.е. в методе bindMatrix мы установим left=-1, right=1, top=1.66, bottom=-1.66. В результате, соотношение сторон near-границы будет точно таким же, как и соотношение сторон экрана. И итоговая картинка ровно растянется на экран без каких-либо искажений.</p>
<p>Соответственно, при повороте экрана в альбомную ориентацию мы получаем разрешение 800*480, и соотношение сторон будет 1.66*1. И в bindMatrix мы установим left=-1.66, right=1.66, top=1, bottom=-1.</p>
<p>Перепишем bindMatrix</p>
<pre><code class="java">private void bindMatrix(int width, int height) {
    float ratio = 1.0f;
    float left = -1.0f;
    float right = 1.0f;
    float bottom = -1.0f;
    float top = 1.0f;
    float near = 1.0f;
    float far = 8.0f;
    if (width &gt; height) {
        ratio = (float) width / height;
        left *= ratio;
        right *= ratio;
    } else {
        ratio = (float) height / width;
        bottom *= ratio;
        top *= ratio;
    }
     
    Matrix.frustumM(mProjectionMatrix, 0, left, right, bottom, top, near, far);
    glUniformMatrix4fv(uMatrixLocation, 1, false, mProjectionMatrix, 0);
}
</code></pre>
<p>Мы используем входные параметры width и height для определения соотношения сторон и для определения ориентации экрана. И в зависимости от ориентации мы устанавливаем высоту и ширину near-границы пропорционально размерам экрана.</p>
<p>Запускаем</p>
<p><img src="data:image/webp;base64,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" alt="" data-pagespeed-url-hash="1090015681" onload="pagespeed.CriticalImages.checkImageForCriticality(this);"/></p>
<p>Поворачиваем экран</p>
<p><img src="data:image/webp;base64,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" alt="" data-pagespeed-url-hash="1014799668" onload="pagespeed.CriticalImages.checkImageForCriticality(this);"/></p>
<p>Теперь результат одинаков</p>
<p>Если по каким-то причинам вам вовсе не нужна перспектива и полноценный 3D, вы можете вместо режима perspective использовать ortho. Отличие ortho от perspective в том, что матрица будет описывать не пирамиду, а параллелограмм.</p>
<p><img src="images/lesson172/lesson2.png" alt="" width="640" height="385"/></p>
<p>В этом режиме объект всегда будет одного размера, независимо от того насколько он удален от камеры. Если вы создаете 2D игру на OpenGL, то этот режим вам вполне подойдет.</p>
<p>Для использования этого режима надо просто формировать матрицу методом orthoM вместо frustumM в bindMatrix.</p>
<p>Попробуйте сами поизменять z-координаты треугольников и убедиться, что перспектива больше не работает.</p>
<p>Я заметил, что в ortho-режиме не отображаются треугольники, если размещать их на уровне near-границы. Т.е. на z=-1 в нашем примере. Пока что не могу объяснить почему так. В perspective-режиме такой проблемы нет.</p>
<p>Непростая выдалась тема и вполне нормально, что понимание придет не сразу. Просто периодически перечитывайте этот урок и постепенно все станет на свои места.</p>
<p>Также очень рекомендую вам скачать демо-программу с <a href="http://www.songho.ca/opengl/gl_transform.html" target="_blank" rel="noopener noreferrer">этой страницы</a>. Ищите там по названию файла: matrixProjection.zip. Качайте архив, распаковывайте и в папке bin запускайте exe-шник</p>
<p><img src="images/lesson172/lesson3.png" alt="" width="640" height="385"/></p>
<p>Вы можете менять projection type: perspective или ortho, и сами задавать параметры для создания матрицы. Обо всем этом мы с вами только что говорили, так что тут вы сможете отлично и наглядно попрактиковаться.</p>
</div>
</div>
</div>
    <script src="../js/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
	</body>
</html>
