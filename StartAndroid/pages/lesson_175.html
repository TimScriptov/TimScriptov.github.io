<!DOCTYPE html>
<html lang="ru">
  
	<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no">
    <meta name="author" content=""/>
    
	<title>Урок 175. OpenGL. Текстуры.</title>
 <link href="../css/bootstrap.css" rel="stylesheet">
    <link href="../css/article_style.css" rel="stylesheet">
    <link href="../css/hightlight-styles/androidstudio.css" rel="stylesheet">
	</head>
	
	<body>
      <div class="page__inner">
      <div class="main main_width-limit">
      <div class="content">
      
		<p>В этом уроке:</p>
<p>- используем текстуры</p>
<p>В прошлых уроках мы рисовали цветные треугольники. В этом уроке заменим цвет на текстуру. Мы можем взять любую картинку и сказать системе, чтобы она "наложила" эту картинку на треугольник вместо простой заливки цветом.</p>
<p>Прежде чем перейдем к практике, нам надо будет обсудить два основных момента при работе с текстурами: <br/> - как из обычной картинки получить текстуру, готовую к работе в OpenGL<br/> - как наложить текстуру на треугольник</p>
<h3>Создание текстуры из картинки</h3>
<p>Начнем с того, как нам картинку передать в OpenGL. Для этого нам придется освоить три понятия: texture <b>unit</b>, texture <b>target</b>, texture <b>object</b>.</p>
<p><b>Texture object</b> – объект текстуры, который хранит в себе текстуру и некоторые ее параметры. Особенности работы с OpenGL таковы, что вы не можете просто так взять и отредактировать этот объект, или использовать его чтобы вывести на экран. Вам необходимо поместить его в определенный слот. И тогда вы сможете этот объект текстуры изменять или использовать в вашем изображении.</p>
<p>Слоты выглядят примерно так</p>
<p><img src="images/lesson175/lesson1.png" alt="" width="640" height="385"/></p>
<p>Каждый большой прямоугольник с подписью GL_TEXTURE&lt;N&gt; (где N = 0,1,2…) – это <b>texture unit</b>. GL_TEXTURE&lt;N&gt; - это имя константы, по которой к нему можно обратиться. Я нарисовал всего три юнита, но их больше.</p>
<p>Каждый маленький прямоугольник внутри большого – это<b> texture target</b>. Его еще можно назвать типом текстуры. И насколько я понял, в OpenGL ES всего два типа: <br/> GL_TEXTURE_2D – обычная двумерная текстура<br/> GL_TEXTURE_CUBE_MAP – текстура развернутого куба. Т.е. это вот такая штука, состоящая из 6-ти квадратов</p>
<p><img src="images/lesson175/lesson2.png" alt="" width="640" height="385"/></p>
<p>Мы в этом уроке будем использовать GL_TEXTURE_2D.</p>
<p>Чтобы работать с объектом текстуры, его надо поместить в target какого-либо юнита. Далее наша работа будет идти уже с этим target. А он уже будет менять объект текстуры.</p>
<p>Т.е. чтобы нам использовать какую-либо 2D картинку как текстуру на экране, надо будет проделать следующие шаги.</p>
<p>1) Прочесть картинку в Bitmap</p>
<p>2) Создать объект текстуры</p>
<p>3) Сделать какой-нибудь юнит активным. Все дальнейшие действия по работе с текстурами система будет выполнять в этом юните. По умолчанию, активен юнит GL_TEXTURE0.</p>
<p>4) Поместить созданный объект текстуры (из п.2.) в какой-либо texture target. В наших примерах обычно это будет GL_TEXTURE_2D. Далее по тексту буду использовать именно этот target. Помещаем объект в target, чтобы иметь возможность работать с этим объектом. Теперь все операции, которые хотим проделать с объектом мы будем адресовать в target.</p>
<p>5) Объект текстуры у нас создан, но не настроен. Нам надо сделать две вещи: закинуть в него Bitmap (из п.1.) и настроить фильтрацию. Фильтрация отвечает за то, какие алгоритмы будут использованы если текстуру приходится сжимать или растягивать, чтобы вывести ее на экран.</p>
<p>Напоминаю, что напрямую с объектом текстуры мы не работаем. Но этот объект уже лежит в target, и мы будем работать с target, а он уже донесет всю информацию до объекта текстуры.</p>
<p>Т.е. для GL_TEXTURE_2D надо указать необходимые режимы фильтрации и передать в него Bitmap. После этого наш объект текстуры будет готов. Можно переходить к шейдеру.</p>
<p>6) Работать с текстурой будет фрагментный шейдер. Именно он отвечает за заполнение фигур пикселами. Только теперь вместо простого цвета он будет определять какую точку из текстуры надо отображать для каждой точки треугольника.</p>
<p>Чтобы шейдер знал какую именно текстуру ему надо использовать, нам надо передать ему эту информацию. Логичнее всего, казалось бы, просто передать в него объект текстуры. Но, к сожалению, все устроено чуть сложнее, чем нам хотелось бы. И в шейдер мы будем передавать не объект текстуры, а номер юнита, в котором сейчас эта текстура находится.</p>
<p>Но мы помним, что текстура находится не просто в юните, но еще и в target. Как тогда шейдер поймет, в каком target указанного юнита ему следует искать текстуру? Это будет зависеть от того, какой тип переменной мы используем в шейдере для представления текстуры. Мы в нашем примере будем использовать тип sampler2D. И благодаря этому типу шейдер поймет, что ему надо брать текстуру из target GL_TEXTURE_2D.</p>
<p>Мы все это чуть дальше разберем на примере. Сейчас, самая главная мысль, которую надо понять – это то, что мы не работаем напрямую с объектом текстуры. Мы помещаем его в определенный target определенного юнита. После этого, мы можем его там менять через target, и фрагментный шейдер может оттуда его взять для вывода на экран.</p>
<h3>Использование текстуры</h3>
<p>Теперь вторая важная теоретическая часть. Нам нужно понять, как текстура будет «натянута» на объект. Рассмотрим на самом простом примере. У нас есть квадрат, который мы нарисовали с помощью двух треугольников.</p>
<p><img src="data:image/webp;base64,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" alt="" data-pagespeed-url-hash="3559963843" onload="pagespeed.CriticalImages.checkImageForCriticality(this);"/></p>
<p>Для упрощения я здесь использую только X и Y координаты. Z здесь не важен абсолютно.</p>
<p>Итак, для рисования квадрата мы использовали 4 вершины. Чтобы на этот квадрат наложить текстуру, нам надо сопоставить вершины квадрата и координаты текстуры.</p>
<p>Текстуру можно представить в таком виде</p>
<p><img src="images/lesson175/lesson3.png" alt="" width="640" height="385"/></p>
<p>Т.е. каждая сторона текстуры считается равной 1 (даже если стороны не равны). И используя эти S и T координаты мы можем указать на любую точку текстуры.</p>
<p>Если мы хотим повесить текстуру на наш квадрат, нам надо просто сопоставить углы квадрата и углы текстуры. Т.е. для каждой вершины квадрата надо указать точку текстуры, которая будет соответствовать этой вершине.</p>
<p>В нашем примере мы сопоставим координаты вершины квадрата и координаты точки текстуры следующим образом:</p>
<p>левая верхняя вершина (-1,1) -&gt; левая верхняя точка текстуры (0,0)</p>
<p>левая нижняя вершина (-1,-1) -&gt; левая нижняя точка текстуры (0,1)</p>
<p>правая верхняя вершина (1,1) -&gt; правая верхняя точка текстуры (1,0)</p>
<p>правая нижняя вершина (1,-1) -&gt; правая нижняя точка текстуры (1,1)</p>
<p>Таким образом мы вершинам квадрата сопоставили углы текстуры и, в результате, текстура ровно ляжет на квадрат и заполнит его целиком.</p>
<p>Тут надо понимать, что текстура будет наложена не на квадрат, а на два треугольника. Ведь мы изображение строим из треугольников. На один треугольник будет наложена одна часть текстуры, а на другой треугольник – вторая часть. В итоге, две части текстуры на двух треугольниках будут выглядеть как целая текстура на квадрате.</p>
<p><img src="images/lesson175/lesson4.png" alt="" width="640" height="385"/></p>
<p>Ну и логично предположить, что, если шейдеры будут заниматься сопоставлением вершин треугольника и координат текстуры, то нам необходимо будет в шейдеры эти данные передавать. Данные о вершинах мы и так уже обычно передаем, а в этом уроке будем добавлять к ним координаты текстур. Когда шейдер получит эти данные он будет знать, какой вершине какая точка текстуры соответствует. А для всех остальных точек треугольника (которые находятся между вершинами) соответствующие им точки текстуры будут рассчитаны интерполяцией.</p>
<p>Этот механизм схож с тем, что мы рассматривали в Уроке 171, когда рисовали градиент. Там мы для каждой вершины указывали цвет, а фрагментный шейдер интерполировал их между вершинами, и мы получали градиент. В случае с текстурой, фрагментный шейдер будет рассчитывать не цвет, а координаты текстуры.</p>
<p>Давайте смотреть код, в котором будет реализовано все то, что мы обсудили. Скачивайте <a href="https://github.com/startandroid/lessons_opengl" target="_blank" rel="noopener noreferrer">исходники</a> и открывайте модуль <b>lesson175_texture</b>.</p>
<p>Сначала посмотрим на класс <b>TextureUtils</b>. В нем есть метод <b>loadTexture</b>. Этот метод принимает на вход id ресурса картинки, а на выходе вернет нам id созданного объекта текстуры, который будет содержать в себе эту картинку. Разберем этот метод подробно.</p>
<p>Методом <b>glGenTextures</b> создаем пустой объект текстуры. В качестве параметров передаем: <br/> - сколько объектов необходимо создать. Нам нужна одна текстура, указываем 1.<br/> - int массив, в который метод поместит id созданных объектов<br/> - offset массива (индекс элемента массива, с которого метод начнет заполнять массив). Тут, как обычно, передаем 0.</p>
<p>Проверяем, если id равен 0, значит что-то пошло не так и объект текстуры не был создан. Возвращаем 0.</p>
<p>Далее идут методы по получению Bitmap из ресурса. Подробно об этом можно почитать в уроках 157-159.</p>
<p>Если Bitmap получить не удалось, то удаляем объект текстуры методом glDeleteTextures. В качестве параметров передаем:<br/> - сколько объектов надо удалить. Нам надо удалить 1 объект.<br/> - массив с id объектов<br/> - offset массива (индекс элемента массива, с которого метод начнет читать массив). Снова 0.</p>
<p>Далее начинается работа с юнитами и target. Методом <b>glActiveTexture</b> делаем активным юнит GL_TEXTURE0, т.е. юнит с номером 0. Теперь все дальнейшие операции будут адресоваться этому юниту. А вот target надо будет указывать в каждой операции.</p>
<p>Методом <b>glBindTexture</b> мы в target GL_TEXTURE_2D помещаем наш объект текстуры, передав туда его id. Заметьте, мы указали только target, без юнита. Потому что юнит мы уже задали одной строкой ранее и система, получив только target, работает с этим target в активном юните.</p>
<p>Методом <b>glTexParameteri</b> мы можем задать параметры объекта текстуры. У этого метода есть три параметра:<br/> - target<br/> - какой параметр будем менять<br/> - значение, которое хотим присвоить этому параметру</p>
<p>В нашем примере мы используем метод glTexParameteri, чтобы задать параметры фильтрации. Напомню, что фильтрация используется, когда размер треугольника не совпадает с размером текстуры, и текстуру приходится сжимать или растягивать, чтобы она ровно села на треугольник.</p>
<p>Существует два параметра фильтрации, которые нам необходимо задать:<br/> GL_TEXTURE_MIN_FILTER  - какой режим фильтрации будет применен при сжатии изображения<br/> GL_TEXTURE_MAG_FILTER - какой режим фильтрации будет применен при растягивании изображения</p>
<p>Обоим этим параметрам мы ставим режим GL_LINEAR. Что означает этот режим и какие еще бывают режимы, я вкратце опишу в конце этого урока, чтобы сейчас не отвлекаться.</p>
<p>Методом <b>texImage2D</b> мы передаем bitmap в объект текстуры. Тут мы указываем target и ранее созданный bitmap. Остальные два параметра оставляем 0, они для нас пока не важны.</p>
<p>Методом <b>recycle</b> мы сообщаем системе, что bitmap нам больше не нужен.</p>
<p>И напоследок снова вызываем метод <b>glBindTexture</b>, в котором в target GL_TEXTURE_2D передаем 0. Тем самым, мы отвязываем наш объект текстуры от этого target.</p>
<p>Т.е. мы сначала поместили объект текстуры в target, выполнили все операции с ним, а затем освободили target. В результате объект текстуры у нас теперь настроен, готов к работе и не привязан ни к какому target.</p>
<p>Смотрим класс <b>OpenGLRenderer</b>. Тут по сравнению с прошлыми уроками есть немного изменений, не касающихся работы с текстурами. Я вынес код по созданию шейдеров и программы в отдельный метод createAndUseProgram. А в метод getLocations я вынес вызовы методов, которые возвращают нам положение переменных в шейдере.</p>
<p>Теперь смотрим новшества, касающиеся текстур. Т.е. что и как мы делаем, чтобы использовать текстуру. Напомню вкратце, что от нас требуется:</p>
<p>1) Создать объект текстуры из картинки<br/><span style="line-height: 15.808px;">2) Сопоставить вершины треугольника и координаты текстуры, и передать эти данные в шейдер, чтобы он знал как, ему следует наложить текстуру на треугольник.<br/></span>3) Поместить объект текстуры в target какого-нибудь юнита<br/>4) Передать в шейдер номер юнита, в котором сейчас находится объект текстуры</p>
<p>Смотрим метод <b>prepareData</b>. В массиве vertices мы задаем данные о 4 вершинах, чтобы нарисовать квадрат. Для каждой вершины мы задаем 5 чисел. Первые три – это координаты вершины, а последние две – это координаты соответствующей точки текстуры.</p>
<p>В переменную texture мы помещаем id объекта текстуры, созданного из картинки box.</p>
<p>В методе <b>getLocations </b>обратите внимание на две новые переменные из шейдеров:<br/> a_Texture – это атрибут в вершинном шейдере. В него будем передавать координаты текстуры.<br/> u_TextureUnit – это uniform переменная, в нее будем передавать номер юнита, в который мы поместим текстуру.</p>
<p>В методе <b>bindData </b>сначала передаем координаты вершин в aPositionLocation. Затем передаем координаты текстуры в aTextureLocation. Т.е. из одного массива мы передаем данные в два атрибута. Мы такое уже делали в Уроке 171. Если вдруг забыли, можно там посмотреть, я очень подробно все расписывал.</p>
<p>Методом <b>glActiveTexture </b>мы делаем активным юнит 0. Он и так по умолчанию активный, но вдруг мы где-то в коде это меняли и делали активным какой-нибудь другой юнит. Поэтому на всякий случай выполняем эту операцию.</p>
<p>Методом <b>glBindTexture </b>помещаем объект текстуры в target GL_TEXTURE_2D.</p>
<p>Методом <b>glUniform1i </b>передаем шейдеру информацию о том, что текстуру он сможет найти в юните 0.</p>
<p>В методе <b>onDrawFrame </b>просим систему нарисовать нам треугольники из 4 вершин. В результате будет нарисован квадрат и на него будет "наложена" текстура.</p>
<p>Теперь смотрим на шейдеры.</p>
<p>Сначала вершинный шейдер <b>vertex_shader.glsl</b>. Здесь мы, как и ранее, вычисляем итоговые координаты (gl_Position) для каждой вершины с помощью матрицы. А в атрибут a_Texture у нас приходят данные по координатам текстуры. И мы их сразу пишем в  varying переменную v_Texture. Это позволит нам в фрагментном шейдере получить интерполированные данные по координатам текстуры.</p>
<p>Фрагментный шейдер <b>fragment_shader.glsl</b>. В нем у нас есть uniform переменная u_TextureUnit, в которую мы получаем номер юнита, в котором находится нужная нам текстура. Обратите внимание на тип переменной. Напомню, что из приложения мы в эту переменную передавали 0, как integer. А тут у нас какой-то сложный тип sampler2D. Меня это немного запутало поначалу, и пришлось покопать этот момент. В итоге я пришел к выводу, что, когда система передает 0 в шейдер в тип sampler2D, она смотрит в юнит 0 и в sampler2D помещает содержимое текстуры из target GL_TEXTURE_2D.</p>
<p>Т.е. переданное в шейдер число (а нашем случае 0) указывает на какой юнит смотреть.  А тип переменной, в которую передано это число (в нашем случае sampler2D) указывает из какого target надо брать текстуру (из 2D target). Естественно это сработает, только, если вы поместили туда текстуру методами glActiveTexture и glBindTexture.</p>
<p>В varying переменную v_Texture приходят интерполированные координаты текстуры из вершинного шейдера. И шейдер знает, какую точку текстуры надо отобразить в текущей точке треугольника.</p>
<p>Осталось использовать координаты текстуры и саму текстуру, чтобы получить итоговый фрагмент. Это выполнит метод <b>texture2D</b>, и в gl_FragColor мы получим цвет нужной точки из текстуры.</p>
<p>Запускаем приложение</p>
<p><img src="images/lesson175/lesson5.png" alt="" width="640" height="385"/></p>
<p>Текстура ровно легла на квадрат. Вернее, части текстуры легли на треугольники и в результате мы видим квадрат.</p>
<h3>Частичное использование текстуры</h3>
<p>Мы в примере использовали всю текстуру от (0,0) до (1,1). Но это вовсе не обязательно. Мы вполне можем использовать лишь часть.</p>
<p>Давайте рассмотрим такую картинку</p>
<p><img src="images/lesson175/lesson6.png" alt="" width="640" height="385"/></p>
<p>В ней содержатся две картинки. А для квадрата нужна только одна, например та, которая находится слева, до 0.5. Чтобы нам ее «наложить» на квадрат, нужно просто поменять сопоставление вершин и точек текстуры. Теперь правые вершины квадрата будут сопоставляться не с правыми углами картинки, а с серединой.</p>
<p>Давайте выведем на экран еще один квадрат с этой левой половиной текстуры</p>
<p>Дополним массив <b>vertices</b>:</p>
<pre><code class="java">float[] vertices = {
        -1,  1, 1,   0, 0,
        -1, -1, 1,   0, 1,
         1,  1, 1,   1, 0,
         1, -1, 1,   1, 1,
 
        -1,  4, 1,   0, 0,
        -1,  2, 1,   0, 1,
         1,  4, 1,   0.5f, 0,
         1,  2, 1,   0.5f, 1,
};
</code></pre>
<p>К 4-м вершинам мы добавили еще 4. Это тоже квадрат, который будет нарисован повыше первого. Координаты текстур для него соответствуют левой половине текстуры.</p>
<p>Т.к. мы будем использовать еще одну текстуру, надо в классе <b>OpenGLRenderer</b> создать еще одну переменную</p>
<pre><code class="java">private int texture2;
</code></pre>
<p>В метод <b>prepareData</b> добавим код создания второго объекта текстуры</p>
<pre><code class="java">texture2 = TextureUtils.loadTexture(context, R.drawable.boxes);
</code></pre>
<p>Перепишем <b>onDrawFrame</b></p>
<pre><code class="java">public void onDrawFrame(GL10 arg0) {
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
 
    glBindTexture(GL_TEXTURE_2D, texture);
    glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);
 
    glBindTexture(GL_TEXTURE_2D, texture2);
    glDrawArrays(GL_TRIANGLE_STRIP, 4, 4);
}
</code></pre>
<p>Здесь мы просим систему нарисовать треугольники сначала из первой четверки вершин, затем из второй четверки вершин. Каждая четверка даст нам по квадрату. А перед рисованием каждого квадрата, мы помещаем соответствующую ему текстуру в target, чтобы шейдер для первого квадрата использовал первую текстуру, а для второго квадрата – вторую.</p>
<p>Запускаем</p>
<p><img src="images/lesson175/lesson7.png" alt="" width="640" height="385"/></p>
<p>Видим еще один квадрат. Шейдер использовал не всю текстуру, а ее левую половину, т.к. мы указали ему это координатами в массиве vertices.</p>
<p>Напоследок еще немного теории</p>
<h3>Несколько юнитов</h3>
<p>Зачем может быть нужно несколько юнитов? Бывают случаи, когда фрагментный шейдер должен использовать сразу несколько текстур, чтобы получить итоговый фрагмент. Тогда ему никак не обойтись без нескольких юнитов, в target-ы которых помещены разные текстуры.</p>
<p>Получить кол-во доступных вам юнитов можно методом glGetIntegerv</p>
<pre><code class="java">glGetIntegerv(GL_MAX_TEXTURE_IMAGE_UNITS, cnt, 0);
</code></pre>
<p>Где, cnt – это массив int[] из одного элемента. В итоге, int[0] будет хранить в себе кол-во юнитов.</p>
<h3>Режимы фильтрации</h3>
<p>Давайте поговорим чуть подробнее про фильтрацию. Что это такое, когда применяется, какие режимы фильтрации существуют?</p>
<p>Итак, нам надо текстуру "натянуть" на треугольник. Точка треугольника называется - фрагмент (отсюда и название фрагментного шейдера, который должен отрисовать каждый фрагмент треугольника). А точка текстуры называется - тексель. Когда текстура накладывается на треугольник, их размеры могут не совпадать, и системе приходится подгонять размер текстуры под размер треугольника. Т.е. впихивать несколько текселей в один фрагмент (minification), если текстура больше треугольника. Либо растягивать один тексель на несколько фрагментов (magnification), если текстура меньше. В этом случае применяется фильтрация, чтобы получить итоговый фрагмент.</p>
<p>Есть два основных режима фильтрации изображения:<br/> NEAREST – для каждого фрагмента просто берется ближайший тексель. Работает быстро, но качество хуже.<br/> LINEAR – для каждого фрагмента берется 4 ближайших текселя и рассчитывается их среднее значение. Медленнее скорость, но лучше качество.</p>
<p>В дополнение к фильтрации может быть применен mipmapping. Он для текстуры создает несколько копий разных размеров - от оригинального до совсем минимального. При выполнении фильтрации берется копия текстуры, которая по размерам ближе всего к треугольнику. Это обеспечит лучшее качество и может ускорить процесс, но увеличивает расход памяти, т.к. вам надо держать в памяти несколько уменьшенных копий текстуры. Подробнее можно посмотреть <a href="https://ru.wikipedia.org/wiki/MIP-%D1%82%D0%B5%D0%BA%D1%81%D1%82%D1%83%D1%80%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5" target="_blank" rel="noopener noreferrer">тут</a>.</p>
<p>Чтобы задействовать mipmapping, необходим такой код:</p>
<pre><code class="java">glGenerateMipmap(GL_TEXTURE_2D);
</code></pre>
<p>Вызывайте его сразу после того, как поместили bitmap в текстуру. Для гарантированного результата, ваша текстура должна иметь POT (power of two) размеры. Т.е. ширина и высота текстуры должны быть равны какой-либо степени двойки: 1, 2, 4, 8, 16, 32 и т.п. Максимальный размер – 2048. При этом текстура не обязана быть квадратной, т.е. ширина может быть не равна высоте, главное, чтобы оба значения были POT.</p>
<p>Существует два способа, как mipmapping может быть использован при фильтрации:<br/> MIPMAP_NEAREST – выбирается копия текстуры наиболее подходящая по размеру и к ней применяется фильтрация, чтобы получить итоговый фрагмент из текселей<br/> MIPMAP_LINEAR – выбираются две копии текстуры наиболее подходящие по размеру, к обоим применяется фильтрация. От фильтрации каждой копии мы получаем по фрагменту, а в качестве итогового фрагмента берем их среднее значение.</p>
<p>Второй способ даст лучшее качество, но первый - быстрее.</p>
<p>Эти два способа подбора копий в комбинации с двумя ранее рассмотренными режимами фильтрации дают нам 4 режима фильтрации:</p>
<p>GL_NEAREST_MIPMAP_NEAREST – фильтрация NEAREST, выбор копии MIPMAP_NEAREST. Т.е. выбирается ближайшая копия текстуры, и к ней применяется NEAREST фильтрация.</p>
<p>GL_NEAREST_MIPMAP_LINEAR - фильтрация NEAREST, выбор копии MIPMAP_LINEAR. Т.е. выбираются две ближайших копии текстуры, и к каждой копии применяется NEAREST фильтрация. Итоговым результатом будет среднее от двух полученных фрагментов.</p>
<p>GL_LINEAR_MIPMAP_NEAREST - фильтрация LINEAR, выбор копии MIPMAP_NEAREST. Т.е. выбирается ближайшая копия текстуры, и к ней применяется LINEAR фильтрация.</p>
<p>GL_LINEAR_MIPMAP_LINEAR - фильтрация LINEAR, выбор копии MIPMAP_LINEAR. Т.е. выбираются две ближайших копии текстуры, и к каждой копии применяется LINEAR фильтрация. Итоговым результатом будет среднее от двух полученных фрагментов.</p>
<p>Итого мы получаем 6 возможных режимов фильтрации:<br/>GL_NEAREST <br/>GL_LINEAR <br/>GL_NEAREST_MIPMAP_NEAREST<br/>GL_LINEAR_MIPMAP_NEAREST<br/>GL_NEAREST_MIPMAP_LINEAR<br/>GL_LINEAR_MIPMAP_LINEAR</p>
<p>Первые два применимы и для minification и для magnification. Остальные четыре – только для minification.</p>
<p>Если снова взглянуть на наш код в методе <b>loadTexture </b>класса <b>TextureUtils</b>:</p>
<pre><code class="java">GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR);
GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR);
</code></pre>
<p>Мы настраиваем два параметра:</p>
<p>GL_TEXTURE_MIN_FILTER – параметр для задания режима фильтрации при minification GL_TEXTURE_MAG_FILTER – параметр для задания режима фильтрации при magnification</p>
<p>В обоих случаях задаем LINEAR фильтрацию.</p>
<h3>Как сделать куб</h3>
<p>Я в <a href="https://telegram.me/startandroid" target="_blank" rel="noopener noreferrer">телеграмм-канал</a> сайта скидывал картинку крутящегося ящика и написал, что вы после этого урока сами сможете такое сделать.</p>
<p><img src="images/lesson175/lesson8.gif" alt="" width="640" height="385"/></p>
<p>Для этого вам нужно будет немного доработать текущий код.</p>
<p>Для начала, отмените все изменения, которые мы внесли в процессе этого урока.</p>
<p>В моем примере есть только одна сторона куба, состоящая из двух треугольников. Вам надо будет дорисовать остальные 5 сторон. Т.е. добавить в массив вершин еще 10 треугольников и правильно сопоставить их с координатами текстуры. Ну и конечно, добавить их отрисовку в onDrawFrame</p>
<p>Текстуру можно для всех сторон использовать одну и ту же. Но если есть желание, можете поискать в инете еще текстуры и сделать куб с разными текстурами для каждой стороны. В этом случае вам надо будет для каждой текстуры создать объект текстуры и помещать его в target перед тем, как вызывать метод отрисовки треугольников соответствующей стороны куба.</p>
<p>А если хотите сделать поворот, то добавляйте model матрицу и настраивайте поворот вокруг оси Y. О том, как это сделать, мы говорили в прошлом уроке.</p>
</div>
</div>
</div>
    <script src="../js/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
	</body>
</html>
